-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\echo4\echo.vhd
-- Created: 2021-03-07 17:24:45
-- 
-- Generated by MATLAB 9.9 and HDL Coder 3.17
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: echo
-- Source Path: echo4/dataplane/echo
-- Hierarchy Level: 1
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.dataplane_pkg.ALL;

ENTITY echo IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_1_2048_0                      :   IN    std_logic;
        input_signal                      :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
        delay_samples                     :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        echo_gain                         :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16_En15
        output_signal                     :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En23
        );
END echo;


ARCHITECTURE rtl OF echo IS

  ATTRIBUTE multstyle : string;

  -- Component Declarations
  COMPONENT circular_buffer_delay
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_2048_0                    :   IN    std_logic;
          signal_in                       :   IN    std_logic_vector(23 DOWNTO 0);  -- sfix24_En23
          delay                           :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
          signal_out                      :   OUT   std_logic_vector(23 DOWNTO 0)  -- sfix24_En23
          );
  END COMPONENT;

  -- Component Configuration Statements
--   FOR ALL : circular_buffer_delay
--     USE ENTITY work.circular_buffer_delay(rtl);

  -- Signals
  SIGNAL input_signal_1                   : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL circular_buffer_delay_out1       : std_logic_vector(23 DOWNTO 0);  -- ufix24
  SIGNAL circular_buffer_delay_out1_1     : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL circular_buffer_delay_out1_2     : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL echo_gain_1                      : unsigned(15 DOWNTO 0);  -- ufix16_En15
  SIGNAL echo_gain_2                      : unsigned(15 DOWNTO 0);  -- ufix16_En15
  SIGNAL Product_cast                     : signed(16 DOWNTO 0);  -- sfix17_En15
  SIGNAL Product_mul_temp                 : signed(40 DOWNTO 0);  -- sfix41_En38
  SIGNAL Product_out1                     : signed(39 DOWNTO 0);  -- sfix40_En38
  SIGNAL delayMatch_reg                   : vector_of_signed24(0 TO 1);  -- sfix24 [2]
  SIGNAL delayMatch_reg_next              : vector_of_signed24(0 TO 1);  -- sfix24_En23 [2]
  SIGNAL input_signal_2                   : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Product_out1_1                   : signed(39 DOWNTO 0);  -- sfix40_En38
  SIGNAL Product_out1_2                   : signed(23 DOWNTO 0);  -- sfix24_En23
  SIGNAL Add1_add_cast                    : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add1_add_cast_1                  : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add1_add_temp                    : signed(24 DOWNTO 0);  -- sfix25_En23
  SIGNAL Add1_out1                        : signed(23 DOWNTO 0);  -- sfix24_En23

BEGIN
  u_circular_buffer_delay : circular_buffer_delay
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_2048_0 => enb_1_2048_0,
              signal_in => input_signal,  -- sfix24_En23
              delay => delay_samples,  -- uint16
              signal_out => circular_buffer_delay_out1  -- sfix24_En23
              );

  input_signal_1 <= signed(input_signal);

  circular_buffer_delay_out1_1 <= signed(circular_buffer_delay_out1);

  HwModeRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      circular_buffer_delay_out1_2 <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        circular_buffer_delay_out1_2 <= circular_buffer_delay_out1_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister_process;


  echo_gain_1 <= unsigned(echo_gain);

  HwModeRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      echo_gain_2 <= to_unsigned(16#0000#, 16);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        echo_gain_2 <= echo_gain_1;
      END IF;
    END IF;
  END PROCESS HwModeRegister1_process;


  Product_cast <= signed(resize(echo_gain_2, 17));
  Product_mul_temp <= circular_buffer_delay_out1_2 * Product_cast;
  Product_out1 <= Product_mul_temp(39 DOWNTO 0);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg(0) <= to_signed(16#000000#, 24);
      delayMatch_reg(1) <= to_signed(16#000000#, 24);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch_reg(0) <= delayMatch_reg_next(0);
        delayMatch_reg(1) <= delayMatch_reg_next(1);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  input_signal_2 <= delayMatch_reg(1);
  delayMatch_reg_next(0) <= input_signal_1;
  delayMatch_reg_next(1) <= delayMatch_reg(0);

  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_out1_1 <= to_signed(0, 40);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product_out1_1 <= Product_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  
  Product_out1_2 <= X"7FFFFF" WHEN (Product_out1_1(39) = '0') AND (Product_out1_1(38) /= '0') ELSE
      X"800000" WHEN (Product_out1_1(39) = '1') AND (Product_out1_1(38) /= '1') ELSE
      Product_out1_1(38 DOWNTO 15);

  Add1_add_cast <= resize(input_signal_2, 25);
  Add1_add_cast_1 <= resize(Product_out1_2, 25);
  Add1_add_temp <= Add1_add_cast + Add1_add_cast_1;
  
  Add1_out1 <= X"7FFFFF" WHEN (Add1_add_temp(24) = '0') AND (Add1_add_temp(23) /= '0') ELSE
      X"800000" WHEN (Add1_add_temp(24) = '1') AND (Add1_add_temp(23) /= '1') ELSE
      Add1_add_temp(23 DOWNTO 0);

  output_signal <= std_logic_vector(Add1_out1);

END rtl;

